<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran_aggregate_across_cells: scran::aggregate_across_cells Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran_aggregate_across_cells
   </div>
   <div id="projectbrief">Aggregate expression values across cells</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescran.html">scran</a></li><li class="navelem"><a class="el" href="namespacescran_1_1aggregate__across__cells.html">aggregate_across_cells</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">scran::aggregate_across_cells Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Aggregate expression values across cells.  
<a href="namespacescran_1_1aggregate__across__cells.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1aggregate__across__cells_1_1Options.html">Options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Further options for <code><a class="el" href="namespacescran_1_1aggregate__across__cells.html#aa8c09dfee9f424daa59e29f2826460dc">aggregate_across_cells::compute()</a></code>.  <a href="structscran_1_1aggregate__across__cells_1_1Options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1aggregate__across__cells_1_1Results.html">Results</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregated results from <code><a class="el" href="namespacescran_1_1aggregate__across__cells.html#aa8c09dfee9f424daa59e29f2826460dc">aggregate_across_cells::compute()</a></code>.  <a href="structscran_1_1aggregate__across__cells_1_1Results.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa8c09dfee9f424daa59e29f2826460dc" id="r_aa8c09dfee9f424daa59e29f2826460dc"><td class="memTemplParams" colspan="2">template&lt;typename Data_ , typename Index_ , typename Factor_ , typename Sum_ , typename Detected_ &gt; </td></tr>
<tr class="memitem:aa8c09dfee9f424daa59e29f2826460dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran_1_1aggregate__across__cells.html#aa8c09dfee9f424daa59e29f2826460dc">compute</a> (const tatami::Matrix&lt; Data_, Index_ &gt; *input, const Factor_ *factor, std::vector&lt; Sum_ * &gt; sums, std::vector&lt; Detected_ * &gt; detected, const <a class="el" href="structscran_1_1aggregate__across__cells_1_1Options.html">Options</a> &amp;options)</td></tr>
<tr class="separator:aa8c09dfee9f424daa59e29f2826460dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5ae1de15376ecfeae0baf4030366a8" id="r_acd5ae1de15376ecfeae0baf4030366a8"><td class="memTemplParams" colspan="2">template&lt;typename Sum_  = double, typename Detected_  = int, typename Data_ , typename Index_ , typename Factor_ &gt; </td></tr>
<tr class="memitem:acd5ae1de15376ecfeae0baf4030366a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1aggregate__across__cells_1_1Results.html">Results</a>&lt; Sum_, Detected_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran_1_1aggregate__across__cells.html#acd5ae1de15376ecfeae0baf4030366a8">compute</a> (const tatami::Matrix&lt; Data_, Index_ &gt; *input, const Factor_ *factor, const <a class="el" href="structscran_1_1aggregate__across__cells_1_1Options.html">Options</a> &amp;options)</td></tr>
<tr class="separator:acd5ae1de15376ecfeae0baf4030366a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Aggregate expression values across cells. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aa8c09dfee9f424daa59e29f2826460dc" name="aa8c09dfee9f424daa59e29f2826460dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c09dfee9f424daa59e29f2826460dc">&#9670;&#160;</a></span>compute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Data_ , typename Index_ , typename Factor_ , typename Sum_ , typename Detected_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scran::aggregate_across_cells::compute </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; Data_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Factor_ *&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Sum_ * &gt;&#160;</td>
          <td class="paramname"><em>sums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Detected_ * &gt;&#160;</td>
          <td class="paramname"><em>detected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran_1_1aggregate__across__cells_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the per-gene sum and number of cells with detected expression for each level of a grouping factor. This is typically done for the creation of pseudo-bulk expression profiles for cluster/sample combinations. Expression values are generally expected to be counts, though the same code can be trivially re-used to compute the average log-expression. We can also report the number of cells with detected (i.e., positive) expression values in each grouping.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Data_</td><td>Type of data in the input matrix, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of index in the input matrix. </td></tr>
    <tr><td class="paramname">Factor_</td><td>Integer type of the factor. </td></tr>
    <tr><td class="paramname">Sum_</td><td>Type of the sum, usually the same as <code>Data</code>. </td></tr>
    <tr><td class="paramname">Detected_</td><td>Type for the number of detected cells, usually integer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">input</td><td>The input matrix where rows are features and columns are cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factor</td><td>Pointer to an array of length equal to the number of columns of <code>input</code>, containing the factor level for each cell. All levels should be integers in <picture><source srcset="form_0_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$[0, N)$" src="form_0.png"/></picture> where <picture><source srcset="form_1_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$N$" src="form_1.png"/></picture> is the number of unique levels. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sums</td><td>Vector of length <picture><source srcset="form_1_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$N$" src="form_1.png"/></picture> (see <code>factor</code>), containing pointers to arrays of length equal to the number of columns of <code>input</code>. These will be filled with the summed expression across all cells in the corresponding level for each gene. Alternatively, if the vector is of length 0, no sums will be computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">detected</td><td>Vector of length <picture><source srcset="form_1_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$N$" src="form_1.png"/></picture> (see <code>factor</code>), containing pointers to arrays of length equal to the number of columns of <code>input</code>. These will be filled with the number of cells with detected expression in the corresponding level for each gene. Alternatively, if the vector is of length 0, no numbers will be computed. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd5ae1de15376ecfeae0baf4030366a8" name="acd5ae1de15376ecfeae0baf4030366a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5ae1de15376ecfeae0baf4030366a8">&#9670;&#160;</a></span>compute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sum_  = double, typename Detected_  = int, typename Data_ , typename Index_ , typename Factor_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1aggregate__across__cells_1_1Results.html">Results</a>&lt; Sum_, Detected_ &gt; scran::aggregate_across_cells::compute </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; Data_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Factor_ *&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran_1_1aggregate__across__cells_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Sum_</td><td>Type of the sum, should be numeric. </td></tr>
    <tr><td class="paramname">Detected_</td><td>Type for the number of detected cells, usually integer. </td></tr>
    <tr><td class="paramname">Data_</td><td>Type of data in the input matrix, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of index in the input matrix. </td></tr>
    <tr><td class="paramname">Factor_</td><td>Integer type of the factor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">input</td><td>The input matrix where rows are features and columns are cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factor</td><td>Pointer to an array of length equal to the number of columns of <code>input</code>, containing the factor level for each cell. All levels should be integers in <picture><source srcset="form_0_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$[0, N)$" src="form_0.png"/></picture> where <picture><source srcset="form_1_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$N$" src="form_1.png"/></picture> is the number of unique levels. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structscran_1_1aggregate__across__cells_1_1Results.html" title="Aggregated results from aggregate_across_cells::compute().">Results</a> of the aggregation, where the available statistics depend on <code><a class="el" href="structscran_1_1aggregate__across__cells_1_1Options.html" title="Further options for aggregate_across_cells::compute().">aggregate_across_cells::Options</a></code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
