<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>aggregate_across_cells: aggregate_across_cells Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">aggregate_across_cells
   </div>
   <div id="projectbrief">Aggregate expression values across cells</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">aggregate_across_cells Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Methods for aggregating across cells.  
<a href="namespaceaggregate__across__cells.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaggregate__across__cells_1_1Combinations.html">Combinations</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique combinations of factors.  <a href="structaggregate__across__cells_1_1Combinations.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaggregate__across__cells_1_1Results.html">Results</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for the aggregation results.  <a href="structaggregate__across__cells_1_1Results.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af56b9866b2ea6f99d6a5c18ebf67ea2d" id="r_af56b9866b2ea6f99d6a5c18ebf67ea2d"><td class="memTemplParams" colspan="2">template&lt;typename Factor , typename Combined &gt; </td></tr>
<tr class="memitem:af56b9866b2ea6f99d6a5c18ebf67ea2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structaggregate__across__cells_1_1Combinations.html">Combinations</a>&lt; Factor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaggregate__across__cells.html#af56b9866b2ea6f99d6a5c18ebf67ea2d">combine_factors</a> (size_t n, const std::vector&lt; const Factor * &gt; &amp;factors, Combined *combined)</td></tr>
<tr class="separator:af56b9866b2ea6f99d6a5c18ebf67ea2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2414f0abd84279090f07fde892581e01" id="r_a2414f0abd84279090f07fde892581e01"><td class="memTemplParams" colspan="2">template&lt;typename Data_ , typename Index_ , typename Factor_ , typename Sum_ , typename Detected_ &gt; </td></tr>
<tr class="memitem:a2414f0abd84279090f07fde892581e01"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaggregate__across__cells.html#a2414f0abd84279090f07fde892581e01">compute</a> (const tatami::Matrix&lt; Data_, Index_ &gt; *input, const Factor_ *factor, std::vector&lt; Sum_ * &gt; sums, std::vector&lt; Detected_ * &gt; detected, const Options &amp;options)</td></tr>
<tr class="separator:a2414f0abd84279090f07fde892581e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26047600abe4a49bb9f220c39acc4f41" id="r_a26047600abe4a49bb9f220c39acc4f41"><td class="memTemplParams" colspan="2">template&lt;typename Sum_  = double, typename Detected_  = int, typename Data_ , typename Index_ , typename Factor_ &gt; </td></tr>
<tr class="memitem:a26047600abe4a49bb9f220c39acc4f41"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structaggregate__across__cells_1_1Results.html">Results</a>&lt; Sum_, Detected_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaggregate__across__cells.html#a26047600abe4a49bb9f220c39acc4f41">compute</a> (const tatami::Matrix&lt; Data_, Index_ &gt; *input, const Factor_ *factor, const Options &amp;options)</td></tr>
<tr class="separator:a26047600abe4a49bb9f220c39acc4f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Methods for aggregating across cells. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="af56b9866b2ea6f99d6a5c18ebf67ea2d" name="af56b9866b2ea6f99d6a5c18ebf67ea2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af56b9866b2ea6f99d6a5c18ebf67ea2d">&#9670;&#160;</a></span>combine_factors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Factor , typename Combined &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structaggregate__across__cells_1_1Combinations.html">Combinations</a>&lt; Factor &gt; aggregate_across_cells::combine_factors </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const Factor * &gt; &amp;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Combined *&#160;</td>
          <td class="paramname"><em>combined</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Factor</td><td>Factor type. Any type may be used here as long as it is comparable. </td></tr>
    <tr><td class="paramname">Combined</td><td>Integer type for the combined factor. This should be large enough to hold the number of unique combinations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Number of observations (i.e., cells). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>Pointers to arrays of length <code>n</code>, each containing a different factor. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">combined</td><td>Pointer to an array of length <code>n</code>, in which the combined factor is to be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structaggregate__across__cells_1_1Combinations.html" title="Unique combinations of factors.">Combinations</a></code> object is returned containing the unique combinations of levels observed in <code>factors</code>. A combined factor is saved to <code>combined</code>, where each entry is an index into the relevant combination of the output <code><a class="el" href="structaggregate__across__cells_1_1Combinations.html" title="Unique combinations of factors.">Combinations</a></code> object. </dd></dl>

</div>
</div>
<a id="a2414f0abd84279090f07fde892581e01" name="a2414f0abd84279090f07fde892581e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2414f0abd84279090f07fde892581e01">&#9670;&#160;</a></span>compute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Data_ , typename Index_ , typename Factor_ , typename Sum_ , typename Detected_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void aggregate_across_cells::compute </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; Data_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Factor_ *&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Sum_ * &gt;&#160;</td>
          <td class="paramname"><em>sums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Detected_ * &gt;&#160;</td>
          <td class="paramname"><em>detected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Options &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the per-gene sum and number of cells with detected expression for each level of a grouping factor. This is typically done for the creation of pseudo-bulk expression profiles for cluster/sample combinations. Expression values are generally expected to be counts, though the same code can be trivially re-used to compute the average log-expression. We can also report the number of cells with detected (i.e., positive) expression values in each grouping.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Data_</td><td>Type of data in the input matrix, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of index in the input matrix. </td></tr>
    <tr><td class="paramname">Factor_</td><td>Integer type of the factor. </td></tr>
    <tr><td class="paramname">Sum_</td><td>Type of the sum, usually the same as <code>Data</code>. </td></tr>
    <tr><td class="paramname">Detected_</td><td>Type for the number of detected cells, usually integer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">input</td><td>The input matrix where rows are features and columns are cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factor</td><td>Pointer to an array of length equal to the number of columns of <code>input</code>, containing the factor level for each cell. All levels should be integers in <picture><source srcset="form_0_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$[0, N)$" src="form_0.png"/></picture> where <picture><source srcset="form_1_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$N$" src="form_1.png"/></picture> is the number of unique levels. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sums</td><td>Vector of length <picture><source srcset="form_1_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$N$" src="form_1.png"/></picture> (see <code>factor</code>), containing pointers to arrays of length equal to the number of columns of <code>input</code>. These will be filled with the summed expression across all cells in the corresponding level for each gene. Alternatively, if the vector is of length 0, no sums will be computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">detected</td><td>Vector of length <picture><source srcset="form_1_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$N$" src="form_1.png"/></picture> (see <code>factor</code>), containing pointers to arrays of length equal to the number of columns of <code>input</code>. These will be filled with the number of cells with detected expression in the corresponding level for each gene. Alternatively, if the vector is of length 0, no numbers will be computed. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26047600abe4a49bb9f220c39acc4f41" name="a26047600abe4a49bb9f220c39acc4f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26047600abe4a49bb9f220c39acc4f41">&#9670;&#160;</a></span>compute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sum_  = double, typename Detected_  = int, typename Data_ , typename Index_ , typename Factor_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structaggregate__across__cells_1_1Results.html">Results</a>&lt; Sum_, Detected_ &gt; aggregate_across_cells::compute </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; Data_, Index_ &gt; *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Factor_ *&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Options &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Sum_</td><td>Type of the sum, should be numeric. </td></tr>
    <tr><td class="paramname">Detected_</td><td>Type for the number of detected cells, usually integer. </td></tr>
    <tr><td class="paramname">Data_</td><td>Type of data in the input matrix, should be numeric. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of index in the input matrix. </td></tr>
    <tr><td class="paramname">Factor_</td><td>Integer type of the factor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">input</td><td>The input matrix where rows are features and columns are cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factor</td><td>Pointer to an array of length equal to the number of columns of <code>input</code>, containing the factor level for each cell. All levels should be integers in <picture><source srcset="form_0_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$[0, N)$" src="form_0.png"/></picture> where <picture><source srcset="form_1_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$N$" src="form_1.png"/></picture> is the number of unique levels. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structaggregate__across__cells_1_1Results.html" title="Container for the aggregation results.">Results</a></code> object is returned, where the available statistics depend on <code>Options</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
